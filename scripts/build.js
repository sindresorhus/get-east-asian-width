import fs from 'node:fs';
import assert from 'node:assert/strict';
import process from 'node:process';
import simplifyRanges from 'simplify-ranges';
import {outdent} from 'outdent';

const CATEGORY_NAMES = new Map([
	['A', 'ambiguous'],
	['F', 'fullwidth'],
	['H', 'halfwidth'],
	['N', 'neutral'],
	['Na', 'narrow'],
	['W', 'wide'],
]);
const GENERATED_CATEGORIES = [
	'ambiguous',
	'fullwidth',
	'halfwidth',
	'narrow',
	'wide',
];

function parse(input) {
	const {version} = input.match(/EastAsianWidth-(?<version>.*)\.txt/).groups;

	// Remove comments
	input = input.replaceAll(/\s*#.*$/gm, '').trim();

	const categories = new Map(Array.from(CATEGORY_NAMES, ([, category]) => [category, []]));

	// Parse input and group by category
	for (const line of input.split('\n')) {
		/*
		https://www.unicode.org/Public/UCD/latest/ucd/EastAsianWidth.txt

		The format is two fields separated by a semicolon.
		Field 0: Unicode code point value or range of code point values
		Field 1: East_Asian_Width property, consisting of one of the following values:
						"A", "F", "H", "N", "Na", "W"
		*/
		const [range, eastAsianWidthProperty] = line.split(';').map(x => x.trim());
		const category = CATEGORY_NAMES.get(eastAsianWidthProperty);
		const [start, end = start] = range.split('..').map(part => Number.parseInt(part, 16));
		categories.get(category).push([start, end]);
	}

	for (const [category, ranges] of categories) {
		const simplified = simplifyRanges(ranges, {separateTwoNumberRanges: true});
		assert.ok(simplified.length > 0);
		categories.set(category, simplified);
	}

	return {
		version,
		categories,
	};
}

// A generated CodePointTrie variant with block shift 8 benchmarks as the fastest strategy.
// However, serializing that trie inflates raw `lookup.js` size by about 10x, so this generator
// keeps packed ranges as the default and leaves lookup logic in `lookup.js`.
function generateDataDeclarations(categories) {
	const declarations = [];
	for (const category of GENERATED_CATEGORIES) {
		const ranges = categories.get(category);
		assert.ok(ranges.length > 0);
		const mergedRanges = simplifyRanges(ranges);
		const variableName = `${category}Ranges`;
		declarations.push({
			name: variableName,
			code: `// prettier-ignore\nconst ${variableName} = [${mergedRanges.flat().join(', ')}];`,
		});
	}

	return declarations;
}

const response = await fetch('https://www.unicode.org/Public/UCD/latest/ucd/EastAsianWidth.txt');
const text = await response.text();
const {
	version,
	categories,
} = parse(text);
const dataDeclarations = generateDataDeclarations(categories);
const dataDeclarationCode = dataDeclarations.map(dataDeclaration => dataDeclaration.code).join('\n\n');
const dataImports = dataDeclarations.map(dataDeclaration => dataDeclaration.name).join(', ');

fs.writeFileSync(
	new URL('../lookup-data.js', import.meta.url),
	outdent`
		// Generated by scripts/build.js

		${dataDeclarationCode}

		export {${dataImports}};
	` + '\n',
);

fs.writeFileSync(new URL('EastAsianWidth.txt', import.meta.url), text);

if (process.argv.includes('--save-version-file')) {
	let versionNumber = version;
	while (versionNumber.endsWith('.0')) {
		versionNumber = versionNumber.slice(0, -2);
	}

	// Save version number to `UNICODE_VERSION` on CI
	fs.writeFileSync(new URL('../UNICODE_VERSION', import.meta.url), versionNumber);
}
