import fs from 'node:fs';
import assert from 'node:assert/strict';
import process from 'node:process';
import simplifyRanges from 'simplify-ranges';
import {outdent} from 'outdent';
import indentString from 'indent-string';

const CATEGORY_NAMES = new Map([
	['A', 'ambiguous'],
	['F', 'fullwidth'],
	['H', 'halfwidth'],
	['N', 'neutral'],
	['Na', 'narrow'],
	['W', 'wide'],
]);
const DEFAULT_CATEGORY = CATEGORY_NAMES.get('N');
const independentFunctions = {
	ambiguous: 'isAmbiguous',
	fullwidth: 'isFullWidth',
	wide: 'isWide',
};

const toHexadecimal = number => number === 0 ? '0' : `0x${number.toString(16).toUpperCase()}`;
const indent = string => indentString(string, 1, {indent: '\t'});

function parse(input) {
	const {version} = input.match(/EastAsianWidth-(?<version>.*)\.txt/).groups;

	// Remove comments
	input = input.replaceAll(/\s*#.*$/gm, '').trim();

	const categories = new Map(Array.from(CATEGORY_NAMES, ([, category]) => [category, []]));

	// Parse input and group by category
	for (const line of input.split('\n')) {
		/*
		https://www.unicode.org/Public/UCD/latest/ucd/EastAsianWidth.txt

		The format is two fields separated by a semicolon.
		Field 0: Unicode code point value or range of code point values
		Field 1: East_Asian_Width property, consisting of one of the following values:
						"A", "F", "H", "N", "Na", "W"
		*/
		const [range, eastAsianWidthProperty] = line.split(';').map(x => x.trim());
		const category = CATEGORY_NAMES.get(eastAsianWidthProperty);
		const [start, end = start] = range.split('..').map(part => Number.parseInt(part, 16));
		categories.get(category).push([start, end]);
	}

	for (const [category, ranges] of categories) {
		const simplified = simplifyRanges(ranges, {separateTwoNumberRanges: true});
		assert.ok(simplified.length > 0);
		categories.set(category, simplified);
	}

	return {
		version,
		categories,
	};
}

function generateConditions(ranges) {
	return ranges.map(([start, end]) =>
		start === end
			? `x === ${toHexadecimal(start)}`
			: `x >= ${toHexadecimal(start)} && x <= ${toHexadecimal(end)}`,
	);
}

function generateFunctions(categories) {
	const preamble = [outdent`
		// Binary search on a sorted flat array of [start, end] pairs.
		const isInRange = (ranges, x) => {
			let low = 0;
			let high = (ranges.length >>> 1) - 1;
			while (low <= high) {
				const mid = (low + high) >>> 1;
				const i = mid * 2;
				if (x < ranges[i]) {
					high = mid - 1;
				} else if (x > ranges[i + 1]) {
					low = mid + 1;
				} else {
					return true;
				}
			}

			return false;
		};
	`];
	const functions = {};
	const branches = [];

	for (const [category, ranges] of categories) {
		if (category === DEFAULT_CATEGORY) {
			continue;
		}

		const functionName = independentFunctions[category];

		if (functionName) {
			const mergedRanges = simplifyRanges(ranges);
			const flatValues = mergedRanges.flat();
			preamble.push(`// prettier-ignore\nconst ${category}Ranges = [${flatValues.join(', ')}];`);
			functions[functionName] = `const ${functionName} = (x) => isInRange(${category}Ranges, x);`;
			branches.push(`if (${functionName}(x)) return '${category}';`);
		} else {
			const conditions = generateConditions(ranges);
			branches.push(outdent`
				if (
					${conditions.join('\n\t|| ')}
				) {
					return '${category}';
				}
			`);
		}
	}

	functions.getCategory = outdent`
		function getCategory(x) {
			${indent(branches.join('\n\n')).trimStart()}

			return '${DEFAULT_CATEGORY}';
		}
	`;

	return {preamble, functions};
}

const response = await fetch('https://www.unicode.org/Public/UCD/latest/ucd/EastAsianWidth.txt');
const text = await response.text();
const {
	version,
	categories,
} = parse(text);
const {preamble, functions} = generateFunctions(categories);
const allCode = [...preamble, ...Object.values(functions)];

fs.writeFileSync(
	new URL('../lookup.js', import.meta.url),
	outdent`
		// Generated by scripts/build.js

		${allCode.join('\n\n')}

		export {${Object.keys(functions).join(', ')}};
	` + '\n',
);

fs.writeFileSync(new URL('EastAsianWidth.txt', import.meta.url), text);

if (process.argv.includes('--save-version-file')) {
	let versionNumber = version;
	while (versionNumber.endsWith('.0')) {
		versionNumber = versionNumber.slice(0, -2);
	}

	// Save version number to `UNICODE_VERSION` on CI
	fs.writeFileSync(new URL('../UNICODE_VERSION', import.meta.url), versionNumber);
}
